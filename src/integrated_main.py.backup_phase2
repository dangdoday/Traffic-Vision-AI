import sys
import cv2
import numpy as np
import os
import math

# CRITICAL: Import YOLO BEFORE PyQt to avoid DLL conflicts
try:
    from ultralytics import YOLO
    print("‚úÖ YOLO imported successfully before PyQt")
    YOLO_AVAILABLE = True
except Exception as e:
    print(f"‚ùå YOLO import failed: {e}")
    YOLO_AVAILABLE = False

from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QListWidget, QFileDialog, QInputDialog, QMessageBox, QComboBox, QSpinBox, QDoubleSpinBox, QMenu, QAction, QMenuBar, QDialog
from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt
from PyQt5.QtGui import QImage, QPixmap, QCursor
from ui.lane_selector import VehicleTypeDialog
import torch
from model_config import scan_all_models, get_weight_path, get_model_config, migrate_old_weights

# Import core OOP modules
from core import VehicleTracker, ViolationDetector, StopLineManager, TrafficLightManager, VideoThread

# Import Direction Detection modules
from core.roi_direction_manager import ROIDirectionManager
from core.trajectory_direction_analyzer import TrajectoryDirectionAnalyzer
from core.direction_fusion import DirectionFusion

# Import ROI Editor
from tools.roi_editor import ROIEditor

# Import Config Manager
from utils.config_manager import ConfigManager

# Import handlers
from handlers import DirectionROIHandlerMixin, ReferenceVectorHandlerMixin, TrafficLightHandlerMixin, LaneHandlerMixin, ConfigHandlerMixin

# Import new modular functions
from app.geometry import point_in_polygon, point_to_segment_distance, is_on_stop_line
from app.detection import (
    tl_pixel_state, classify_tl_color,
    calculate_vehicle_direction, estimate_vehicle_speed,
    check_tl_violation, check_speed_violation, check_lane_direction_match,
    set_vehicle_positions_ref, set_violation_checker_globals
)

# Traffic light state - Support multiple traffic lights with types
TL_ROIS = []  # List of (x1, y1, x2, y2, tl_type, current_color) tuples - NO stoplines needed
# tl_type: 'ƒëi th·∫≥ng', 'tr√≤n', 'r·∫Ω tr√°i', 'r·∫Ω ph·∫£i'

# Direction Detection ROIs
# Format: {'name': 'roi_1', 'points': [[x,y], ...], 'allowed_directions': ['left', 'straight'], 'primary_direction': 'straight'}
DIRECTION_ROIS = []  
_tmp_direction_roi_pts = []  # Temporary points while drawing direction ROI
_selected_direction = 'straight'  # Current selected direction for drawing
_selected_directions_multi = ['straight']  # Multiple directions allowed (for complex lanes)

# ROI Editing variables
_editing_roi_index = None  # Index of ROI being edited (None = not editing)
_editing_roi_type = None  # 'lane', 'direction', or 'tl'
_dragging_point_index = None  # Index of point being dragged
_hover_point_index = None  # Index of point being hovered
_hover_edge_indices = None  # (point1_idx, point2_idx) of edge being hovered for insertion

# Vehicle tracking for direction detection
VEHICLE_POSITIONS = {}  # {track_id: [(x, y, timestamp), ...]} - last N positions for direction calc
VEHICLE_DIRECTIONS = {}  # {track_id: 'straight', 'left', 'right', 'unknown'}

# Link VEHICLE_POSITIONS to direction_detector module
set_vehicle_positions_ref(VEHICLE_POSITIONS)

# Link TL_ROIS, DIRECTION_ROIS, VEHICLE_DIRECTIONS to violation_checker module
set_violation_checker_globals(TL_ROIS, DIRECTION_ROIS, VEHICLE_DIRECTIONS)

# NOTE: tl_pixel_state, classify_tl_color, point_in_polygon are imported from modules
# See imports at top of file:
#   from app.geometry import point_in_polygon, point_to_segment_distance, is_on_stop_line
#   from app.detection import tl_pixel_state, classify_tl_color, ...

# Global variables
LANE_CONFIGS = []
STOP_LINE = None  # Single stopline: (p1, p2)
_tmp_lane_pts = []
_tmp_stop_point = None
_tmp_tl_point = None  # For manual TL ROI selection
_drawing_mode = None  # 'lane' or 'stopline' or 'tl_manual' or 'direction_roi' or 'ref_vector' or None
_detection_running = False
_show_all_boxes = True  # True = show all vehicles, False = show only violators

# Detection variables
VIOLATOR_TRACK_IDS = set()
RED_LIGHT_VIOLATORS = set()
LANE_VIOLATORS = set()
PASSED_VEHICLES = set()  # Track vehicles that passed stop line
MOTORBIKE_COUNT = set()  # Track motorbikes (xe m√°y)
CAR_COUNT = set()  # Track cars/trucks/buses (√¥ t√¥, xe t·∫£i, xe bus)
VEHICLE_CLASSES = {0: "o to", 1: "xe bus", 2: "xe dap", 3: "xe may", 4: "xe tai"}  # Custom model classes
ALLOWED_VEHICLE_IDS = [0, 1, 2, 3, 4]

def is_on_stop_line(cx, cy, threshold=15):
    """Check if point is on THE stopline"""
    global STOP_LINE
    if STOP_LINE is None:
        return False
    p1, p2 = STOP_LINE
    dist = point_to_segment_distance(cx, cy, p1[0], p1[1], p2[0], p2[1])
    return dist < threshold

# NOTE: calculate_vehicle_direction and estimate_vehicle_speed are imported from app.detection
# They use VEHICLE_POSITIONS via set_vehicle_positions_ref() called above

# NOTE: check_speed_violation is imported from app.detection (100% identical)

# NOTE: check_lane_direction_match and check_tl_violation are imported from app.detection
# They use TL_ROIS, DIRECTION_ROIS, VEHICLE_DIRECTIONS via set_violation_checker_globals() called above


class MainWindow(QMainWindow, DirectionROIHandlerMixin, ReferenceVectorHandlerMixin, TrafficLightHandlerMixin, LaneHandlerMixin, ConfigHandlerMixin):
    def __init__(self):
        super().__init__()
        
        # Declare globals used in this method
        global VIOLATOR_TRACK_IDS, RED_LIGHT_VIOLATORS, LANE_VIOLATORS, PASSED_VEHICLES, MOTORBIKE_COUNT, CAR_COUNT
        global ALLOWED_VEHICLE_IDS, VEHICLE_CLASSES, LANE_CONFIGS, TL_ROIS, _show_all_boxes
        global DIRECTION_ROIS, _tmp_direction_roi_pts, _selected_direction
        
        # Initialize ROI Editor
        self.roi_editor = ROIEditor()
        
        # Ask user to select video FIRST before showing main UI
        video_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Video File to Start",
            "",
            "Video Files (*.mp4 *.avi *.mov *.mkv);;All Files (*.*)"
        )
        
        if not video_path:
            # User cancelled - exit application
            print("‚ùå No video selected. Exiting...")
            QApplication.quit()
            return
        
        self.video_path = video_path
        print(f"üìπ Selected video: {video_path}")
        
        # Now setup the UI
        self.setWindowTitle("Traffic Violation Detector - Integrated")
        self.setGeometry(50, 50, 1600, 900)
        
        # Pre-load YOLO model in main thread to avoid DLL issues in QThread
        self.yolo_model = None
        self.current_model_type = None
        self.current_model_config = None
        
        # Try to migrate old weights first
        migrate_old_weights()
        
        # Scan available models
        self.available_models = scan_all_models()
        print(f"üì¶ Available models: {list(self.available_models.keys())}")
        
        # Setup menu bar AFTER available_models is initialized
        self.setup_menu_bar()
        
        # Auto-load first available model
        if YOLO_AVAILABLE and self.available_models:
            first_model_type = list(self.available_models.keys())[0]
            first_weight = self.available_models[first_model_type]["weights"][0]
            self.load_model(first_model_type, first_weight)
        else:
            print("‚ö†Ô∏è YOLO not available or no models found, detection disabled")
        
        # Initialize TL tracking (manual ROI only, no auto-detection)
        self.tl_tracking_active = False  # Continuous color tracking flag
        self.tl_color_frame_count = 0  # Counter for color update throttling
        self.cap = None  # Will be set when video loads
        print("‚úÖ Manual TL ROI mode enabled")
        
        # Initialize display scale variables for accurate click detection
        self.current_display_scale = 1.0
        self.current_display_width = 1024
        self.current_display_height = 768
        self.current_display_offset_x = 0
        self.current_display_offset_y = 0
        
        # Main layout
        main_layout = QHBoxLayout()
        
        # Left side - Video display
        self.video_label = QLabel()
        self.video_label.setScaledContents(False)
        self.video_label.setAlignment(Qt.AlignCenter)  # Center the pixmap to match offset calculation
        self.video_label.setMinimumSize(1024, 768)
        self.video_label.mousePressEvent = self.video_mouse_press
        self.video_label.mouseMoveEvent = self.video_mouse_move
        self.video_label.mouseReleaseEvent = self.video_mouse_release
        self.video_label.mouseDoubleClickEvent = self.video_mouse_double_click
        
        # Enable context menu on video label
        self.video_label.setContextMenuPolicy(Qt.CustomContextMenu)
        self.video_label.customContextMenuRequested.connect(self.show_context_menu)
        
        main_layout.addWidget(self.video_label)
        
        # Right side - Control panel
        control_layout = QVBoxLayout()
        
        # Model selection
        control_layout.addWidget(QLabel("Model Selection"))
        
        self.model_type_combo = QComboBox()
        for model_type, info in self.available_models.items():
            self.model_type_combo.addItem(f"{model_type} - {info['config']['description']}")
        self.model_type_combo.currentIndexChanged.connect(self.on_model_type_changed)
        control_layout.addWidget(self.model_type_combo)
        
        self.weight_combo = QComboBox()
        self.update_weight_combo()
        self.weight_combo.currentIndexChanged.connect(self.on_weight_changed)
        control_layout.addWidget(self.weight_combo)
        
        self.model_info_label = QLabel("")
        self.update_model_info_label()
        control_layout.addWidget(self.model_info_label)
        
        # Model parameters
        control_layout.addWidget(QLabel("Detection Parameters"))
        
        # Image size control
        imgsz_layout = QHBoxLayout()
        imgsz_layout.addWidget(QLabel("ImgSize:"))
        self.imgsz_spinbox = QSpinBox()
        self.imgsz_spinbox.setMinimum(320)
        self.imgsz_spinbox.setMaximum(1280)
        self.imgsz_spinbox.setSingleStep(32)
        self.imgsz_spinbox.setValue(416 if self.current_model_config else 416)
        self.imgsz_spinbox.valueChanged.connect(self.on_imgsz_changed)
        imgsz_layout.addWidget(self.imgsz_spinbox)
        control_layout.addLayout(imgsz_layout)
        
        # Confidence threshold control
        conf_layout = QHBoxLayout()
        conf_layout.addWidget(QLabel("Confidence:"))
        self.conf_spinbox = QDoubleSpinBox()
        self.conf_spinbox.setMinimum(0.1)
        self.conf_spinbox.setMaximum(0.95)
        self.conf_spinbox.setSingleStep(0.05)
        self.conf_spinbox.setDecimals(2)
        self.conf_spinbox.setValue(0.3 if self.current_model_config else 0.3)
        self.conf_spinbox.valueChanged.connect(self.on_conf_changed)
        conf_layout.addWidget(self.conf_spinbox)
        control_layout.addLayout(conf_layout)
        
        # Lane management
        control_layout.addWidget(QLabel("Lane Management"))
        self.lane_list = QListWidget()
        control_layout.addWidget(self.lane_list)
        
        self.btn_add_lane = QPushButton("Add Lane (Click on video)")
        self.btn_add_lane.clicked.connect(self.start_add_lane)
        control_layout.addWidget(self.btn_add_lane)
        
        self.btn_delete_lane = QPushButton("Delete Selected Lane")
        self.btn_delete_lane.clicked.connect(self.delete_lane)
        control_layout.addWidget(self.btn_delete_lane)
        
        # Stop line management
        control_layout.addWidget(QLabel("Stop Line (Single)"))
        
        self.btn_add_stopline = QPushButton("Set Stop Line (Click 2 points)")
        self.btn_add_stopline.clicked.connect(self.start_add_stopline)
        control_layout.addWidget(self.btn_add_stopline)
        
        self.btn_delete_stopline = QPushButton("Delete Stop Line")
        self.btn_delete_stopline.clicked.connect(self.delete_stopline)
        control_layout.addWidget(self.btn_delete_stopline)
        
        # Start detection
        self.btn_start = QPushButton("Start Detection")
        self.btn_start.clicked.connect(self.start_detection)
        control_layout.addWidget(self.btn_start)
        
        # Toggle bounding box display
        self.btn_toggle_bb = QPushButton("Show All Boxes: ON")
        self.btn_toggle_bb.setCheckable(True)
        self.btn_toggle_bb.setChecked(True)
        self.btn_toggle_bb.clicked.connect(self.toggle_bbox_display)
        control_layout.addWidget(self.btn_toggle_bb)
        
        # Select video button
        self.btn_select_video = QPushButton("Select Video File")
        self.btn_select_video.clicked.connect(self.select_video)
        control_layout.addWidget(self.btn_select_video)

        # Traffic light tools
        self.btn_find_tl = QPushButton("Add Traffic Light (Draw ROI)")
        self.btn_find_tl.clicked.connect(self.find_tl_roi)
        control_layout.addWidget(self.btn_find_tl)
        
        self.btn_delete_tl = QPushButton("Delete Traffic Light")
        self.btn_delete_tl.clicked.connect(self.delete_tl)
        control_layout.addWidget(self.btn_delete_tl)
        
        # Direction Detection tools
        control_layout.addWidget(QLabel("Direction ROI Management"))
        
        # Direction selector (dropdown instead of keyboard)
        dir_select_layout = QHBoxLayout()
        dir_select_layout.addWidget(QLabel("Direction:"))
        self.direction_combo = QComboBox()
        self.direction_combo.addItems(["left", "straight", "right"])
        self.direction_combo.setCurrentText("straight")
        self.direction_combo.currentTextChanged.connect(self.on_direction_changed)
        dir_select_layout.addWidget(self.direction_combo)
        control_layout.addLayout(dir_select_layout)
        
        self.btn_add_direction_roi = QPushButton("Draw Direction ROI (Click points)")
        self.btn_add_direction_roi.clicked.connect(self.start_add_direction_roi)
        control_layout.addWidget(self.btn_add_direction_roi)
        
        self.btn_finish_direction_roi = QPushButton("Finish Direction ROI")
        self.btn_finish_direction_roi.clicked.connect(self.finish_direction_roi)
        self.btn_finish_direction_roi.setEnabled(False)
        control_layout.addWidget(self.btn_finish_direction_roi)
        
        self.direction_roi_list = QListWidget()
        control_layout.addWidget(self.direction_roi_list)
        
        self.btn_delete_direction_roi = QPushButton("Delete Selected Direction ROI")
        self.btn_delete_direction_roi.clicked.connect(self.delete_direction_roi)
        control_layout.addWidget(self.btn_delete_direction_roi)
        
        # Edit Direction ROI tool
        self.btn_edit_direction_roi = QPushButton("Edit Selected Direction ROI")
        self.btn_edit_direction_roi.clicked.connect(self.start_edit_direction_roi)
        control_layout.addWidget(self.btn_edit_direction_roi)
        
        self.btn_finish_edit_roi = QPushButton("Finish Editing ROI")
        self.btn_finish_edit_roi.clicked.connect(self.finish_edit_roi)
        self.btn_finish_edit_roi.setEnabled(False)
        control_layout.addWidget(self.btn_finish_edit_roi)
        
        self.btn_smooth_roi = QPushButton("Smooth ROI (reduce points)")
        self.btn_smooth_roi.clicked.connect(self.smooth_current_roi)
        self.btn_smooth_roi.setEnabled(False)
        control_layout.addWidget(self.btn_smooth_roi)
        
        self.btn_change_roi_direction = QPushButton("Change ROI Directions")
        self.btn_change_roi_direction.clicked.connect(self.change_roi_directions)
        self.btn_change_roi_direction.setEnabled(False)
        control_layout.addWidget(self.btn_change_roi_direction)
        
        # Toggle show direction ROIs
        self.btn_toggle_direction_rois = QPushButton("Show Direction ROIs: ON")
        self.btn_toggle_direction_rois.setCheckable(True)
        self.btn_toggle_direction_rois.setChecked(True)
        self.btn_toggle_direction_rois.clicked.connect(self.toggle_direction_rois)
        control_layout.addWidget(self.btn_toggle_direction_rois)
        
        # Reference Vector (for camera nghi√™ng)
        control_layout.addWidget(QLabel("Reference Vector (Camera Tilted)"))
        
        self.btn_set_ref_vector = QPushButton("Set Reference Vector (2 points)")
        self.btn_set_ref_vector.clicked.connect(self.start_set_reference_vector)
        control_layout.addWidget(self.btn_set_ref_vector)
        
        self.btn_finish_ref_vector = QPushButton("Finish Reference Vector")
        self.btn_finish_ref_vector.clicked.connect(self.finish_reference_vector)
        self.btn_finish_ref_vector.setEnabled(False)
        control_layout.addWidget(self.btn_finish_ref_vector)
        
        self.ref_vector_label = QLabel("‚ö†Ô∏è Ref Vector: Not set - Required for turn detection!")
        self.ref_vector_label.setStyleSheet("QLabel { color: orange; font-weight: bold; }")
        self.ref_vector_label.setWordWrap(True)
        control_layout.addWidget(self.ref_vector_label)
        
        # Add helpful hint
        ref_vector_hint = QLabel("üí° Hint: Click 2 points on a STRAIGHT lane\n(from start to end in traffic flow direction)")
        ref_vector_hint.setStyleSheet("QLabel { color: gray; font-size: 9pt; font-style: italic; }")
        ref_vector_hint.setWordWrap(True)
        control_layout.addWidget(ref_vector_hint)
        
        self.show_direction_rois = True
        self.show_lanes = True  # Toggle for lane display
        self.show_roi_overlays = True  # Toggle for ROI overlay display
        self.ref_vector_p1 = None
        self.ref_vector_p2 = None
        
        # Config Manager
        self.config_manager = ConfigManager()
        
        # Save/Load Configuration buttons
        control_layout.addWidget(QLabel("Configuration Management"))
        
        self.btn_save_config = QPushButton("üíæ Save All ROIs Configuration")
        self.btn_save_config.clicked.connect(self.save_configuration)
        self.btn_save_config.setStyleSheet("QPushButton { font-weight: bold; background-color: #4CAF50; color: white; }")
        control_layout.addWidget(self.btn_save_config)
        
        self.btn_load_config = QPushButton("üìÇ Load Configuration")
        self.btn_load_config.clicked.connect(self.load_configuration)
        control_layout.addWidget(self.btn_load_config)
        
        self.config_status_label = QLabel("Config: Not loaded")
        self.config_status_label.setStyleSheet("QLabel { color: gray; font-style: italic; }")
        control_layout.addWidget(self.config_status_label)
        
        self.status_label = QLabel("Status: Ready - Direction-based detection")
        control_layout.addWidget(self.status_label)
        
        control_layout.addStretch()
        
        # Hide control panel - all controls moved to menu bar
        # main_layout.addLayout(control_layout)  # COMMENTED OUT
        
        # Add status bar instead
        self.statusBar().showMessage("Ready - Direction-based detection")
        
        # Create central widget and set layout (video only)
        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)
        
        # Store control_layout reference for future use if needed
        self.control_layout = control_layout
        self.control_panel_visible = False
        
        # Video thread - start with selected video
        self.thread = VideoThread(self.video_path)
        self.thread.change_pixmap_signal.connect(self.update_image)
        self.thread.error_signal.connect(self.show_error)
        
        # Pass globals reference to thread
        # Use lambda for _show_all_boxes to get real-time value
        self.thread.set_globals_reference({
            'ALLOWED_VEHICLE_IDS': ALLOWED_VEHICLE_IDS,
            'VEHICLE_CLASSES': VEHICLE_CLASSES,
            'LANE_CONFIGS': LANE_CONFIGS,
            'TL_ROIS': TL_ROIS,
            'DIRECTION_ROIS': DIRECTION_ROIS,
            'get_show_all_boxes': lambda: globals()['_show_all_boxes'],
            'is_on_stop_line': is_on_stop_line,
            'check_tl_violation': check_tl_violation,
            'point_in_polygon': point_in_polygon,
            'VIOLATOR_TRACK_IDS': VIOLATOR_TRACK_IDS,
            'RED_LIGHT_VIOLATORS': RED_LIGHT_VIOLATORS,
            'LANE_VIOLATORS': LANE_VIOLATORS,
            'PASSED_VEHICLES': PASSED_VEHICLES,
            'MOTORBIKE_COUNT': MOTORBIKE_COUNT,
            'CAR_COUNT': CAR_COUNT
        })
        
        # Set model and config to thread if loaded
        if self.yolo_model is not None:
            self.thread.set_model(self.yolo_model)
            self.thread.model_config = self.current_model_config
        
        self.thread.start()
        
        # Initialize cap and current_frame for TL detection
        self.current_frame = None
        self.cap = cv2.VideoCapture(self.video_path)
        
        # Wait for first frame before auto-detect
        import time
        time.sleep(0.5)  # Wait for video thread to emit first frame
        
        # Trigger auto-detect after first frame is ready
        if self.cap.isOpened():
            ret, first_frame = self.cap.read()
            if ret:
                self.current_frame = first_frame
            self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)  # Reset to start
        
        # No auto-detect - user will draw TL ROIs manually
        self.update_lists()
    
    def show_context_menu(self, pos):
        """Show context menu on video area with organized actions"""
        if self.current_frame is None:
            return
        
        menu = QMenu(self)
        
        # === DRAWING MODE Section ===
        drawing_menu = menu.addMenu("üé® Drawing Mode")
        
        # Lane drawing
        action_draw_lane = QAction("Add Lane (polygon)", self)
        action_draw_lane.triggered.connect(self.start_add_lane)
        drawing_menu.addAction(action_draw_lane)
        
        # Stopline drawing
        action_draw_stopline = QAction("Set Stop Line (2 points)", self)
        action_draw_stopline.triggered.connect(self.start_add_stopline)
        drawing_menu.addAction(action_draw_stopline)
        
        # Traffic light
        action_draw_tl = QAction("Add Traffic Light (draw ROI)", self)
        action_draw_tl.triggered.connect(self.find_tl_roi)
        drawing_menu.addAction(action_draw_tl)
        
        # Direction ROI
        action_draw_direction = QAction("Draw Direction ROI (polygon)", self)
        action_draw_direction.triggered.connect(self.start_add_direction_roi)
        drawing_menu.addAction(action_draw_direction)
        
        # Reference vector
        drawing_menu.addSeparator()
        action_ref_vector = QAction("Set Reference Vector (2 points)", self)
        action_ref_vector.triggered.connect(self.start_set_reference_vector)
        drawing_menu.addAction(action_ref_vector)
        
        menu.addSeparator()
        
        # === EDIT MODE Section ===
        edit_menu = menu.addMenu("‚úèÔ∏è Edit Mode")
        
        # Edit direction ROI
        action_edit_direction = QAction("Edit Selected Direction ROI", self)
        action_edit_direction.triggered.connect(self.start_edit_direction_roi)
        action_edit_direction.setEnabled(self.direction_roi_list.currentRow() >= 0)
        edit_menu.addAction(action_edit_direction)
        
        # Smooth ROI
        action_smooth = QAction("Smooth ROI (reduce points)", self)
        action_smooth.triggered.connect(self.smooth_current_roi)
        action_smooth.setEnabled(self.roi_editor.is_editing())
        edit_menu.addAction(action_smooth)
        
        # Change directions
        action_change_dir = QAction("Change ROI Directions", self)
        action_change_dir.triggered.connect(self.change_roi_directions)
        action_change_dir.setEnabled(self.roi_editor.is_editing())
        edit_menu.addAction(action_change_dir)
        
        edit_menu.addSeparator()
        
        # Finish editing
        action_finish_edit = QAction("Finish Editing ROI", self)
        action_finish_edit.triggered.connect(self.finish_edit_roi)
        action_finish_edit.setEnabled(self.roi_editor.is_editing())
        edit_menu.addAction(action_finish_edit)
        
        menu.addSeparator()
        
        # === DELETE Section ===
        delete_menu = menu.addMenu("üóëÔ∏è Delete")
        
        action_delete_lane = QAction("Delete Selected Lane", self)
        action_delete_lane.triggered.connect(self.delete_lane)
        action_delete_lane.setEnabled(self.lane_list.currentRow() >= 0)
        delete_menu.addAction(action_delete_lane)
        
        action_delete_stopline = QAction("Delete Stop Line", self)
        action_delete_stopline.triggered.connect(self.delete_stopline)
        action_delete_stopline.setEnabled(STOP_LINE is not None)
        delete_menu.addAction(action_delete_stopline)
        
        action_delete_tl = QAction("Delete Traffic Light", self)
        action_delete_tl.triggered.connect(self.delete_tl)
        action_delete_tl.setEnabled(len(TL_ROIS) > 0)
        delete_menu.addAction(action_delete_tl)
        
        action_delete_direction = QAction("Delete Direction ROI", self)
        action_delete_direction.triggered.connect(self.delete_direction_roi)
        action_delete_direction.setEnabled(self.direction_roi_list.currentRow() >= 0)
        delete_menu.addAction(action_delete_direction)
        
        menu.addSeparator()
        
        # === VIEW Section ===
        view_menu = menu.addMenu("üëÅÔ∏è View Options")
        
        # Toggle direction ROIs
        action_toggle_dir = QAction("Toggle Direction ROIs", self)
        action_toggle_dir.setCheckable(True)
        action_toggle_dir.setChecked(self.show_direction_rois)
        action_toggle_dir.triggered.connect(self.toggle_direction_rois)
        view_menu.addAction(action_toggle_dir)
        
        # Toggle all boxes
        action_toggle_boxes = QAction("Show All Bounding Boxes", self)
        action_toggle_boxes.setCheckable(True)
        action_toggle_boxes.setChecked(_show_all_boxes)
        action_toggle_boxes.triggered.connect(self.toggle_bbox_display)
        view_menu.addAction(action_toggle_boxes)
        
        menu.addSeparator()
        
        # === CONFIG Section ===
        config_menu = menu.addMenu("üíæ Configuration")
        
        action_save_config = QAction("Save All ROIs Configuration", self)
        action_save_config.triggered.connect(self.save_configuration)
        config_menu.addAction(action_save_config)
        
        action_load_config = QAction("Load Configuration", self)
        action_load_config.triggered.connect(self.load_configuration)
        config_menu.addAction(action_load_config)
        
        # Show menu at cursor position
        menu.exec_(self.video_label.mapToGlobal(pos))
        
    def video_mouse_press(self, event):
        global _drawing_mode, _tmp_lane_pts, _tmp_stop_point, LANE_CONFIGS, STOP_LINE
        global _tmp_direction_roi_pts, DIRECTION_ROIS
        
        if self.current_frame is None:
            return
        
        from PyQt5.QtCore import Qt
        
        # Use stored scale information for accurate click detection
        if not hasattr(self, 'current_display_scale'):
            return
        
        # Get click position relative to label
        click_x = event.pos().x() - self.current_display_offset_x
        click_y = event.pos().y() - self.current_display_offset_y
        
        # Convert to frame coordinates using stored scale
        if 0 <= click_x < self.current_display_width and 0 <= click_y < self.current_display_height:
            frame_x = int(click_x / self.current_display_scale)
            frame_y = int(click_y / self.current_display_scale)
            
            # Handle ROI editing mode first
            if self.roi_editor.is_editing():
                roi_idx = self.roi_editor.editing_roi_index
                if roi_idx < len(DIRECTION_ROIS):
                    points = DIRECTION_ROIS[roi_idx]['points']
                    button_name = 'right' if event.button() == Qt.RightButton else 'left'
                    self.roi_editor.handle_mouse_press(frame_x, frame_y, button_name, points)
                return
            
            if _drawing_mode == 'lane':
                _tmp_lane_pts.append((frame_x, frame_y))
                print(f"üìç ƒêi·ªÉm {len(_tmp_lane_pts)} c·ªßa lane: ({frame_x}, {frame_y})")
            elif _drawing_mode == 'stopline':
                global STOP_LINE
                if _tmp_stop_point is None:
                    _tmp_stop_point = (frame_x, frame_y)
                    print(f"üìç ƒêi·ªÉm ƒë·∫ßu v·∫°ch d·ª´ng: ({frame_x}, {frame_y})")
                    self.status_label.setText("Status: Click second point for THE stop line")
                else:
                    p1 = _tmp_stop_point
                    p2 = (frame_x, frame_y)
                    STOP_LINE = (p1, p2)
                    print(f"üö¶ ƒê√£ t·∫°o v·∫°ch d·ª´ng: {p1} -> {p2}")
                    _tmp_stop_point = None
                    _drawing_mode = None
                    self.status_label.setText("Status: Stopline created. Direction tracking enabled.")
            elif _drawing_mode == 'direction_roi':
                # Add point to direction ROI
                _tmp_direction_roi_pts.append([frame_x, frame_y])
                print(f"üìç Direction ROI point {len(_tmp_direction_roi_pts)}: ({frame_x}, {frame_y})")
                self.status_label.setText(f"Status: Direction ROI - {len(_tmp_direction_roi_pts)} points. Click 'Finish' when done.")
            elif _drawing_mode == 'ref_vector':
                # Reference vector for camera nghi√™ng
                if self.ref_vector_p1 is None:
                    self.ref_vector_p1 = (frame_x, frame_y)
                    print(f"üìç Ref Vector P1: ({frame_x}, {frame_y})")
                    self.status_label.setText("Status: Click END point on straight lane")
                elif self.ref_vector_p2 is None:
                    self.ref_vector_p2 = (frame_x, frame_y)
                    print(f"üìç Ref Vector P2: ({frame_x}, {frame_y})")
                    self.status_label.setText("Status: Click 'Finish Reference Vector'")
            elif _drawing_mode == 'tl_manual':
                global _tmp_tl_point, TL_ROIS
                if _tmp_tl_point is None:
                    _tmp_tl_point = (frame_x, frame_y)
                    print(f"üìç TL ROI ƒëi·ªÉm 1: ({frame_x}, {frame_y})")
                    self.status_label.setText("Status: Click second point for TL ROI")
                else:
                    p1 = _tmp_tl_point
                    p2 = (frame_x, frame_y)
                    x1, y1 = min(p1[0], p2[0]), min(p1[1], p2[1])
                    x2, y2 = max(p1[0], p2[0]), max(p1[1], p2[1])
                    
                    # Ask user to select TL type
                    tl_types = ['ƒëi th·∫≥ng', 'tr√≤n', 'r·∫Ω tr√°i', 'r·∫Ω ph·∫£i']
                    tl_type, ok = QInputDialog.getItem(
                        self,
                        "Select Traffic Light Type",
                        "Ch·ªçn lo·∫°i ƒë√®n giao th√¥ng:",
                        tl_types,
                        editable=False
                    )
                    
                    if not ok:
                        # User cancelled - reset
                        _tmp_tl_point = None
                        _drawing_mode = None
                        self.status_label.setText("Status: TL selection cancelled")
                        return
                    
                    # Add to list with 6-tuple format (position + type + color) - NO stoplines
                    TL_ROIS.append((x1, y1, x2, y2, tl_type, 'unknown'))
                    print(f"üö¶ TL ROI created: ({x1},{y1},{x2},{y2}) Type={tl_type}")
                    print(f"üìç Use vehicle direction to match with TL type")
                    
                    # Enable color tracking
                    self.tl_tracking_active = True
                    print("üö¶ HSV color tracking started")
                    
                    _tmp_tl_point = None
                    _drawing_mode = None
                    
                    self.status_label.setText(f"Status: TL {len(TL_ROIS)} added ({tl_type}). Total: {len(TL_ROIS)} TL(s)")
                    self.btn_find_tl.setText("Add Traffic Light")
                    self.btn_find_tl.clicked.disconnect()
                    self.btn_find_tl.clicked.connect(self.find_tl_roi)
    
    def video_mouse_move(self, event):
        """Handle mouse move for dragging points and hover effects"""
        global DIRECTION_ROIS
        
        if self.current_frame is None:
            return
        
        # Only handle if editing
        if not self.roi_editor.is_editing():
            return
        
        # Get mouse position in frame coordinates
        label_width = self.video_label.width()
        label_height = self.video_label.height()
        frame_height, frame_width = self.current_frame.shape[:2]
        
        scale = min(label_width / frame_width, label_height / frame_height)
        display_width = int(frame_width * scale)
        display_height = int(frame_height * scale)
        
        offset_x = (label_width - display_width) // 2
        offset_y = (label_height - display_height) // 2
        
        mouse_x = event.pos().x() - offset_x
        mouse_y = event.pos().y() - offset_y
        
        if 0 <= mouse_x < display_width and 0 <= mouse_y < display_height:
            frame_x = int(mouse_x / scale)
            frame_y = int(mouse_y / scale)
            
            roi_idx = self.roi_editor.editing_roi_index
            if roi_idx < len(DIRECTION_ROIS):
                points = DIRECTION_ROIS[roi_idx]['points']
                self.roi_editor.handle_mouse_move(frame_x, frame_y, points)
    
    def video_mouse_release(self, event):
        """Stop dragging point"""
        self.roi_editor.handle_mouse_release()
    
    def video_mouse_double_click(self, event):
        """Double-click on edge to insert new point"""
        global DIRECTION_ROIS
        from PyQt5.QtCore import Qt
        
        if event.button() != Qt.LeftButton:
            return
        
        if not self.roi_editor.is_editing():
            return
        
        if self.current_frame is None:
            return
        
        # Get click position in frame coordinates
        label_width = self.video_label.width()
        label_height = self.video_label.height()
        frame_height, frame_width = self.current_frame.shape[:2]
        
        scale = min(label_width / frame_width, label_height / frame_height)
        display_width = int(frame_width * scale)
        display_height = int(frame_height * scale)
        
        offset_x = (label_width - display_width) // 2
        offset_y = (label_height - display_height) // 2
        
        click_x = event.pos().x() - offset_x
        click_y = event.pos().y() - offset_y
        
        if 0 <= click_x < display_width and 0 <= click_y < display_height:
            frame_x = int(click_x / scale)
            frame_y = int(click_y / scale)
            
            roi_idx = self.roi_editor.editing_roi_index
            if roi_idx < len(DIRECTION_ROIS):
                points = DIRECTION_ROIS[roi_idx]['points']
                if self.roi_editor.handle_double_click(frame_x, frame_y, points):
                    self.update_direction_roi_list()
        
    def update_image(self, frame):
        global _tmp_lane_pts, _tmp_stop_point, _drawing_mode, _detection_running
        global _tmp_direction_roi_pts
        
        self.current_frame = frame.copy()
        display = frame.copy()
        
        # Update TL colors continuously (HSV pixel counting)
        self.update_tl_colors(display)
        
        # Draw direction ROIs (if enabled)
        if self.show_direction_rois and self.show_roi_overlays:
            display = self.draw_direction_rois(display)
        
        # Draw lanes and stop line (if enabled)
        if self.show_lanes:
            display = self.draw_lanes(display)
            display = self.draw_stop_line(display)
        
        # Draw temporary lane
        if _drawing_mode == 'lane' and len(_tmp_lane_pts) > 0:
            pts_tmp = np.array(_tmp_lane_pts, dtype=np.int32)
            cv2.polylines(display, [pts_tmp], isClosed=False, color=(0, 255, 0), thickness=2)
            for p in _tmp_lane_pts:
                cv2.circle(display, p, 4, (0, 255, 0), -1)
        
        # Draw temporary stop line point
        if _drawing_mode == 'stopline' and _tmp_stop_point is not None:
            cv2.circle(display, _tmp_stop_point, 5, (0, 0, 255), -1)
        
        # Draw temporary direction ROI
        if _drawing_mode == 'direction_roi' and len(_tmp_direction_roi_pts) > 0:
            DIRECTION_COLORS = {
                'left': (0, 0, 255),
                'right': (0, 165, 255),
                'straight': (0, 255, 0)
            }
            color = DIRECTION_COLORS.get(_selected_direction, (128, 128, 128))
            pts_tmp = np.array(_tmp_direction_roi_pts, dtype=np.int32)
            cv2.polylines(display, [pts_tmp], isClosed=False, color=color, thickness=2)
            for p in _tmp_direction_roi_pts:
                cv2.circle(display, tuple(p), 5, color, -1)
        
        # Draw temporary TL point
        if _drawing_mode == 'tl_manual' and _tmp_tl_point is not None:
            cv2.circle(display, _tmp_tl_point, 6, (0, 200, 255), -1)
            cv2.putText(display, "P1", (_tmp_tl_point[0]+8, _tmp_tl_point[1]), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 200, 255), 2)
        
        # Draw reference vector (for direction calibration)
        if self.ref_vector_p1 is not None and self.ref_vector_p2 is not None:
            import math
            p1 = self.ref_vector_p1
            p2 = self.ref_vector_p2
            # Draw arrow showing reference direction
            cv2.arrowedLine(display, p1, p2, (255, 0, 255), 3, tipLength=0.05)
            # Draw start/end points
            cv2.circle(display, p1, 6, (255, 0, 255), -1)
            cv2.circle(display, p2, 6, (255, 0, 255), -1)
            # Draw label with angle
            mid = ((p1[0] + p2[0]) // 2, (p1[1] + p2[1]) // 2)
            dx = p2[0] - p1[0]
            dy = p2[1] - p1[1]
            angle = math.degrees(math.atan2(dy, dx))
            cv2.putText(display, f"REF: {angle:.1f} deg", (mid[0] + 10, mid[1] - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 255), 2, cv2.LINE_AA)
        elif _drawing_mode == 'ref_vector' and self.ref_vector_p1 is not None:
            # Show first point while waiting for second
            cv2.circle(display, self.ref_vector_p1, 6, (255, 0, 255), -1)
            cv2.putText(display, "Click second point", (self.ref_vector_p1[0] + 10, self.ref_vector_p1[1] - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 255), 2, cv2.LINE_AA)
        
        # Overlay ALL TL ROIs and labels
        global TL_ROIS
        for idx, tl_data in enumerate(TL_ROIS):
            x1, y1, x2, y2, tl_type, current_color = tl_data
            # Color code by current light color
            box_color = (128, 128, 128)  # Gray default
            if current_color == 'ƒë·ªè':
                box_color = (0, 0, 255)  # Red
                color_display = "DO"
            elif current_color == 'xanh':
                box_color = (0, 255, 0)  # Green
                color_display = "XANH"
            elif current_color == 'v√†ng':
                box_color = (0, 255, 255)  # Yellow
                color_display = "VANG"
            else:
                color_display = "???"
            
            # Map tl_type to ASCII for display
            if tl_type == 'tr√≤n':
                type_display = "tron"
            elif tl_type == 'ƒëi th·∫≥ng':
                type_display = "thang"
            elif tl_type == 'r·∫Ω tr√°i':
                type_display = "L"
            elif tl_type == 'r·∫Ω ph·∫£i':
                type_display = "R"
            else:
                type_display = tl_type
            
            cv2.rectangle(display, (x1, y1), (x2, y2), box_color, 2)
            label_text = f"TL{idx+1}[{type_display}]: {color_display}"
            cv2.putText(display, label_text, (x1, max(0, y1 - 8)), cv2.FONT_HERSHEY_SIMPLEX, 0.5, box_color, 2, cv2.LINE_AA)
        
        # Convert to QImage
        rgb_image = cv2.cvtColor(display, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb_image.shape
        bytes_per_line = ch * w
        qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
        
        # Scale to fit label while maintaining aspect ratio
        scaled_pixmap = QPixmap.fromImage(qt_image).scaled(
            self.video_label.width(), 
            self.video_label.height(), 
            aspectRatioMode=1  # Keep aspect ratio
        )
        
        # Store scale information for accurate click detection
        self.current_display_scale = min(
            self.video_label.width() / w,
            self.video_label.height() / h
        )
        self.current_display_width = int(w * self.current_display_scale)
        self.current_display_height = int(h * self.current_display_scale)
        self.current_display_offset_x = (self.video_label.width() - self.current_display_width) // 2
        self.current_display_offset_y = (self.video_label.height() - self.current_display_height) // 2
        
        self.video_label.setPixmap(scaled_pixmap)
    
    def draw_direction_rois(self, frame):
        """Draw direction ROIs with transparency"""
        global DIRECTION_ROIS
        
        if not DIRECTION_ROIS:
            return frame
        
        overlay = frame.copy()
        
        DIRECTION_COLORS = {
            'left': (0, 0, 255),      # ƒê·ªè
            'right': (0, 165, 255),   # V√†ng
            'straight': (0, 255, 0),  # Xanh
            'unknown': (128, 128, 128)
        }
        
        # Vietnamese labels without accents
        DIRECTION_LABELS = {
            'left': 'RE TRAI',
            'right': 'RE PHAI', 
            'straight': 'DI THANG',
            'unknown': 'UNKNOWN'
        }
        
        for i, roi in enumerate(DIRECTION_ROIS):
            pts = np.array(roi['points'], dtype=np.int32)
            color = DIRECTION_COLORS.get(roi['direction'], DIRECTION_COLORS['unknown'])
            
            # Fill polygon v·ªõi ƒë·ªô trong su·ªët
            cv2.fillPoly(overlay, [pts], color)
            
            # V·∫Ω vi·ªÅn
            cv2.polylines(frame, [pts], True, color, 2)
            
            # V·∫Ω label ·ªü gi·ªØa ROI
            center_x = int(np.mean([p[0] for p in roi['points']]))
            center_y = int(np.mean([p[1] for p in roi['points']]))
            
            direction_text = DIRECTION_LABELS.get(roi['direction'], roi['direction'].upper())
            cv2.putText(frame, direction_text, (center_x - 50, center_y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
        
        # Blend overlay v·ªõi frame
        alpha = 0.25
        frame = cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0)
        
        # Draw editing overlay if in edit mode
        if self.roi_editor.is_editing():
            roi_idx = self.roi_editor.editing_roi_index
            if roi_idx < len(DIRECTION_ROIS):
                points = DIRECTION_ROIS[roi_idx]['points']
                self.roi_editor.draw_editing_overlay(frame, points)
        
        return frame
        
    def keyPressEvent(self, event):
        """Handle keyboard shortcuts for finishing drawings"""
        from PyQt5.QtCore import Qt
        global _drawing_mode
        
        # Enter/Return key to finish drawing
        if event.key() in (Qt.Key_Return, Qt.Key_Enter):
            if _drawing_mode == 'lane':
                # Finish lane drawing
                self.finish_lane()
                return
            elif _drawing_mode == 'direction_roi':
                # Finish direction ROI drawing
                self.finish_direction_roi()
                return
            elif _drawing_mode == 'ref_vector':
                # Finish reference vector
                self.finish_reference_vector()
                return
        
        # Call parent class handler for other keys
        super().keyPressEvent(event)
    
    def setup_menu_bar(self):
        """Setup menu bar with organized menus"""
        menubar = self.menuBar()
        
        # === FILE Menu ===
        file_menu = menubar.addMenu("üìÅ &File")
        
        # Select video
        action_select_video = QAction("Open Video...", self)
        action_select_video.setShortcut("Ctrl+O")
        action_select_video.triggered.connect(self.select_video)
        file_menu.addAction(action_select_video)
        
        file_menu.addSeparator()
        
        # Save/Load config
        action_save_config = QAction("üíæ Save Configuration", self)
        action_save_config.setShortcut("Ctrl+S")
        action_save_config.triggered.connect(self.save_configuration)
        file_menu.addAction(action_save_config)
        
        action_load_config = QAction("üìÇ Load Configuration", self)
        action_load_config.setShortcut("Ctrl+L")
        action_load_config.triggered.connect(self.load_configuration)
        file_menu.addAction(action_load_config)
        
        file_menu.addSeparator()
        
        # Exit
        action_exit = QAction("Exit", self)
        action_exit.setShortcut("Ctrl+Q")
        action_exit.triggered.connect(self.close)
        file_menu.addAction(action_exit)
        
        # === DRAW Menu ===
        draw_menu = menubar.addMenu("üé® &Draw")
        
        # Lane
        action_add_lane = QAction("Add Lane (Polygon)", self)
        action_add_lane.setShortcut("L")
        action_add_lane.triggered.connect(self.start_add_lane)
        draw_menu.addAction(action_add_lane)
        
        # Stopline
        action_add_stopline = QAction("Set Stop Line", self)
        action_add_stopline.setShortcut("S")
        action_add_stopline.triggered.connect(self.start_add_stopline)
        draw_menu.addAction(action_add_stopline)
        
        # Traffic light
        action_add_tl = QAction("Add Traffic Light", self)
        action_add_tl.setShortcut("T")
        action_add_tl.triggered.connect(self.find_tl_roi)
        draw_menu.addAction(action_add_tl)
        
        # Direction ROI
        action_add_direction = QAction("Draw Direction ROI", self)
        action_add_direction.setShortcut("D")
        action_add_direction.triggered.connect(self.start_add_direction_roi)
        draw_menu.addAction(action_add_direction)
        
        draw_menu.addSeparator()
        
        # Reference vector
        action_ref_vector = QAction("Set Reference Vector", self)
        action_ref_vector.setShortcut("R")
        action_ref_vector.triggered.connect(self.start_set_reference_vector)
        draw_menu.addAction(action_ref_vector)
        
        # === EDIT Menu ===
        edit_menu = menubar.addMenu("‚úèÔ∏è &Edit")
        
        # Edit direction ROI
        self.action_edit_direction = QAction("Edit Selected Direction ROI", self)
        self.action_edit_direction.setShortcut("E")
        self.action_edit_direction.triggered.connect(self.start_edit_direction_roi)
        edit_menu.addAction(self.action_edit_direction)
        
        # Smooth ROI
        self.action_smooth_roi = QAction("Smooth ROI", self)
        self.action_smooth_roi.triggered.connect(self.smooth_current_roi)
        self.action_smooth_roi.setEnabled(False)
        edit_menu.addAction(self.action_smooth_roi)
        
        # Change directions
        self.action_change_directions = QAction("Change ROI Directions", self)
        self.action_change_directions.triggered.connect(self.change_roi_directions)
        self.action_change_directions.setEnabled(False)
        edit_menu.addAction(self.action_change_directions)
        
        edit_menu.addSeparator()
        
        # Finish editing
        self.action_finish_edit = QAction("Finish Editing", self)
        self.action_finish_edit.setShortcut("Return")
        self.action_finish_edit.triggered.connect(self.finish_edit_roi)
        self.action_finish_edit.setEnabled(False)
        edit_menu.addAction(self.action_finish_edit)
        
        # === DELETE Menu ===
        delete_menu = menubar.addMenu("üóëÔ∏è De&lete")
        
        action_delete_lane = QAction("Delete Selected Lane", self)
        action_delete_lane.setShortcut("Delete")
        action_delete_lane.triggered.connect(self.delete_lane)
        delete_menu.addAction(action_delete_lane)
        
        action_delete_stopline = QAction("Delete Stop Line", self)
        action_delete_stopline.triggered.connect(self.delete_stopline)
        delete_menu.addAction(action_delete_stopline)
        
        action_delete_tl = QAction("Delete Traffic Light", self)
        action_delete_tl.triggered.connect(self.delete_tl)
        delete_menu.addAction(action_delete_tl)
        
        action_delete_direction = QAction("Delete Direction ROI", self)
        action_delete_direction.triggered.connect(self.delete_direction_roi)
        delete_menu.addAction(action_delete_direction)
        
        # === VIEW Menu ===
        view_menu = menubar.addMenu("üëÅÔ∏è &View")
        
        # Toggle direction ROIs
        self.action_toggle_direction_rois = QAction("Show Direction ROIs", self)
        self.action_toggle_direction_rois.setCheckable(True)
        self.action_toggle_direction_rois.setChecked(True)
        self.action_toggle_direction_rois.triggered.connect(self.toggle_direction_rois)
        view_menu.addAction(self.action_toggle_direction_rois)
        
        # Toggle all boxes
        self.action_toggle_boxes = QAction("Show All Bounding Boxes", self)
        self.action_toggle_boxes.setCheckable(True)
        self.action_toggle_boxes.setChecked(True)
        self.action_toggle_boxes.triggered.connect(self.toggle_bbox_display)
        view_menu.addAction(self.action_toggle_boxes)
        
        # === SETTINGS Menu ===
        settings_menu = menubar.addMenu("‚öôÔ∏è &Settings")
        
        # Model selection submenu
        model_menu = settings_menu.addMenu("ü§ñ Model Selection")
        
        # Will be populated dynamically
        self.model_type_actions = []
        for model_type, info in self.available_models.items():
            action = QAction(f"{model_type} - {info['config']['description']}", self)
            action.setData(model_type)
            action.triggered.connect(lambda checked, mt=model_type: self.load_model_from_menu(mt))
            model_menu.addAction(action)
            self.model_type_actions.append(action)
        
        settings_menu.addSeparator()
        
        # Detection parameters submenu
        params_menu = settings_menu.addMenu("üìä Detection Parameters")
        
        # Add image size action
        action_imgsz = QAction("Set Image Size...", self)
        action_imgsz.triggered.connect(self.show_imgsz_dialog)
        params_menu.addAction(action_imgsz)
        
        # Add confidence action
        action_conf = QAction("Set Confidence Threshold...", self)
        action_conf.triggered.connect(self.show_conf_dialog)
        params_menu.addAction(action_conf)
        
        # === LISTS Menu ===
        lists_menu = menubar.addMenu("üìã &Lists")
        
        # Toggle displays
        self.action_toggle_lanes = QAction("‚úÖ Show Lanes", self)
        self.action_toggle_lanes.setCheckable(True)
        self.action_toggle_lanes.setChecked(True)
        self.action_toggle_lanes.triggered.connect(self.toggle_lane_display)
        lists_menu.addAction(self.action_toggle_lanes)
        
        self.action_toggle_rois = QAction("‚úÖ Show Direction ROIs", self)
        self.action_toggle_rois.setCheckable(True)
        self.action_toggle_rois.setChecked(True)
        self.action_toggle_rois.triggered.connect(self.toggle_roi_display)
        lists_menu.addAction(self.action_toggle_rois)
        
        lists_menu.addSeparator()
        
        # Edit items
        action_edit_lane = QAction("Edit Lane...", self)
        action_edit_lane.triggered.connect(self.show_edit_lane_dialog)
        lists_menu.addAction(action_edit_lane)
        
        action_edit_roi = QAction("Edit Direction ROI...", self)
        action_edit_roi.triggered.connect(self.show_edit_roi_dialog)
        lists_menu.addAction(action_edit_roi)
        
        # === DETECTION Menu ===
        detection_menu = menubar.addMenu("üöÄ &Detection")
        
        self.action_start_detection = QAction("Start Detection", self)
        self.action_start_detection.setShortcut("Space")
        self.action_start_detection.triggered.connect(self.start_detection)
        detection_menu.addAction(self.action_start_detection)
        
        # === HELP Menu ===
        help_menu = menubar.addMenu("‚ùì &Help")
        
        action_about = QAction("About", self)
        action_about.triggered.connect(self.show_about)
        help_menu.addAction(action_about)
        
        action_shortcuts = QAction("Keyboard Shortcuts", self)
        action_shortcuts.setShortcut("F1")
        action_shortcuts.triggered.connect(self.show_shortcuts)
        help_menu.addAction(action_shortcuts)
    
    def show_about(self):
        '''Show about dialog'''
        QMessageBox.about(
            self,
            "About Traffic Violation Detector",
            "<h2>Traffic Violation Detection System</h2>"
            "<p>Version 2.0</p>"
            "<p>Advanced traffic violation detection using YOLOv8</p>"
            "<p><b>Features:</b></p>"
            "<ul>"
            "<li>Lane violation detection</li>"
            "<li>Stopline crossing detection</li>"
            "<li>Traffic light violation (direction-aware)</li>"
            "<li>Multi-direction ROI support</li>"
            "<li>Reference vector for tilted cameras</li>"
            "<li>Auto save/load configuration</li>"
            "</ul>"
        )
    
    def show_shortcuts(self):
        '''Show keyboard shortcuts help'''
        QMessageBox.information(
            self,
            "Keyboard Shortcuts",
            "<h3>Keyboard Shortcuts</h3>"
            "<table>"
            "<tr><td><b>Ctrl+O</b></td><td>Open Video</td></tr>"
            "<tr><td><b>Ctrl+S</b></td><td>Save Configuration</td></tr>"
            "<tr><td><b>Ctrl+L</b></td><td>Load Configuration</td></tr>"
            "<tr><td><b>Ctrl+Q</b></td><td>Exit</td></tr>"
            "<tr><td colspan='2'><hr></td></tr>"
            "<tr><td><b>L</b></td><td>Add Lane</td></tr>"
            "<tr><td><b>S</b></td><td>Set Stop Line</td></tr>"
            "<tr><td><b>T</b></td><td>Add Traffic Light</td></tr>"
            "<tr><td><b>D</b></td><td>Draw Direction ROI</td></tr>"
            "<tr><td><b>R</b></td><td>Set Reference Vector</td></tr>"
            "<tr><td colspan='2'><hr></td></tr>"
            "<tr><td><b>Enter</b></td><td>Finish Drawing (Lane/ROI/Ref Vector)</td></tr>"
            "<tr><td><b>E</b></td><td>Edit Direction ROI</td></tr>"
            "<tr><td><b>Return</b></td><td>Finish Editing</td></tr>"
            "<tr><td><b>Delete</b></td><td>Delete Selected</td></tr>"
            "<tr><td colspan='2'><hr></td></tr>"
            "<tr><td><b>Space</b></td><td>Start/Stop Detection</td></tr>"
            "<tr><td><b>F1</b></td><td>Show This Help</td></tr>"
            "<tr><td colspan='2'><hr></td></tr>"
            "<tr><td><b>Right-Click</b></td><td>Context Menu on Video</td></tr>"
            "</table>"
        )
    
    def load_model_from_menu(self, model_type):
        """Load model when selected from menu"""
        if model_type in self.available_models:
            first_weight = self.available_models[model_type]["weights"][0]
            self.load_model(model_type, first_weight)
            self.statusBar().showMessage(f"Loaded model: {model_type}")
    
    def show_imgsz_dialog(self):
        """Show dialog to set image size"""
        from PyQt5.QtWidgets import QInputDialog
        current_imgsz = self.imgsz_spinbox.value()
        imgsz, ok = QInputDialog.getInt(
            self,
            "Set Image Size",
            "Enter image size (320-1280, multiple of 32):",
            current_imgsz,
            320,
            1280,
            32
        )
        if ok:
            self.imgsz_spinbox.setValue(imgsz)
            self.on_imgsz_changed(imgsz)
            self.statusBar().showMessage(f"Image size set to: {imgsz}")
    
    def show_conf_dialog(self):
        """Show dialog to set confidence threshold"""
        from PyQt5.QtWidgets import QInputDialog
        current_conf = self.conf_spinbox.value()
        conf, ok = QInputDialog.getDouble(
            self,
            "Set Confidence Threshold",
            "Enter confidence threshold (0.1-0.95):",
            current_conf,
            0.1,
            0.95,
            2
        )
        if ok:
            self.conf_spinbox.setValue(conf)
            self.on_conf_changed(conf)
            self.statusBar().showMessage(f"Confidence threshold set to: {conf:.2f}")
    
    def show_lane_list_dialog(self):
        """Show dialog with lane list"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Lane List")
        dialog.setMinimumSize(400, 300)
        
        layout = QVBoxLayout()
        
        lane_list = QListWidget()
        for idx, lane in enumerate(LANE_CONFIGS, start=1):
            allowed = lane.get('allowed_labels', ['all'])
            lane_list.addItem(f"Lane {idx}: {len(lane['poly'])} points - {', '.join(allowed)}")
        
        layout.addWidget(QLabel("<b>Configured Lanes:</b>"))
        layout.addWidget(lane_list)
        
        btn_close = QPushButton("Close")
        btn_close.clicked.connect(dialog.close)
        layout.addWidget(btn_close)
        
        dialog.setLayout(layout)
        dialog.exec_()
    
    def show_direction_list_dialog(self):
        """Show dialog with direction ROI list"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Direction ROI List")
        dialog.setMinimumSize(500, 400)
        
        layout = QVBoxLayout()
        
        direction_list = QListWidget()
        for idx, roi in enumerate(DIRECTION_ROIS, start=1):
            primary_dir = roi.get('primary_direction', roi.get('direction', 'unknown')).upper()
            secondary_dirs = roi.get('secondary_directions', [])
            allowed_dirs = [primary_dir] + [d.upper() for d in secondary_dirs]
            
            # Get traffic light info
            tl_colors = []
            for tl_idx in roi.get('tl_ids', []):
                if tl_idx < len(TL_ROIS):
                    color = TL_ROIS[tl_idx].get('last_color', 'unknown')
                    tl_colors.append(f"TL{tl_idx + 1}:{color}")
            
            tl_info = ' | '.join(tl_colors) if tl_colors else 'No TL'
            points = roi.get('points', [])
            direction_list.addItem(
                f"ROI {idx}: {', '.join(allowed_dirs)} - {len(points)} pts - {tl_info}"
            )
        
        layout.addWidget(QLabel("<b>Configured Direction ROIs:</b>"))
        layout.addWidget(direction_list)
        
        btn_close = QPushButton("Close")
        btn_close.clicked.connect(dialog.close)
        layout.addWidget(btn_close)
        
        dialog.setLayout(layout)
        dialog.exec_()
    
    def toggle_lane_display(self):
        """Toggle lane overlay on/off"""
        self.show_lanes = self.action_toggle_lanes.isChecked()
        status = "ON" if self.show_lanes else "OFF"
        print(f"üîµ Lane display: {status}")
        self.status_label.setText(f"Status: Lane display {status}")
    
    def toggle_roi_display(self):
        """Toggle direction ROI overlay on/off"""
        self.show_roi_overlays = self.action_toggle_rois.isChecked()
        status = "ON" if self.show_roi_overlays else "OFF"
        print(f"üîµ Direction ROI display: {status}")
        self.status_label.setText(f"Status: Direction ROI display {status}")
    
    def show_edit_roi_dialog(self):
        """Show dialog to select and edit a direction ROI"""
        global DIRECTION_ROIS
        
        if not DIRECTION_ROIS:
            QMessageBox.information(self, "No ROIs", "No direction ROIs configured yet. Please add ROIs first.")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Direction ROI")
        dialog.setMinimumSize(500, 400)
        
        layout = QVBoxLayout()
        
        # ROI list
        roi_list = QListWidget()
        for idx, roi in enumerate(DIRECTION_ROIS, start=1):
            primary_dir = roi.get('primary_direction', roi.get('direction', 'unknown')).upper()
            secondary_dirs = roi.get('secondary_directions', [])
            allowed_dirs = [primary_dir] + [d.upper() for d in secondary_dirs]
            points = roi.get('points', [])
            roi_list.addItem(f"ROI {idx}: {', '.join(allowed_dirs)} - {len(points)} points")
        
        layout.addWidget(QLabel("<b>Select a direction ROI to edit:</b>"))
        layout.addWidget(roi_list)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        btn_edit = QPushButton("Edit Selected")
        btn_edit.clicked.connect(lambda: self.start_edit_selected_roi(roi_list.currentRow(), dialog))
        btn_layout.addWidget(btn_edit)
        
        btn_delete = QPushButton("Delete Selected")
        btn_delete.clicked.connect(lambda: self.delete_selected_roi(roi_list.currentRow(), dialog))
        btn_layout.addWidget(btn_delete)
        
        btn_close = QPushButton("Close")
        btn_close.clicked.connect(dialog.close)
        btn_layout.addWidget(btn_close)
        
        layout.addLayout(btn_layout)
        dialog.setLayout(layout)
        dialog.exec_()
    
    def start_edit_selected_roi(self, roi_idx, dialog):
        """Start editing the selected direction ROI"""
        global DIRECTION_ROIS
        
        if roi_idx < 0 or roi_idx >= len(DIRECTION_ROIS):
            QMessageBox.warning(self, "Invalid Selection", "Please select a ROI to edit.")
            return
        
        dialog.close()
        
        # Start ROI editor
        self.roi_editor.start_editing(roi_idx)
        self.action_smooth_roi.setEnabled(True)
        self.action_change_directions.setEnabled(True)
        self.action_finish_edit.setEnabled(True)
        
        print(f"‚úèÔ∏è Editing Direction ROI {roi_idx + 1}")
        self.status_label.setText(f"Status: Editing ROI {roi_idx + 1} - Drag points to adjust")

    
    def delete_selected_roi(self, roi_idx, dialog):
        """Delete the selected direction ROI"""
        global DIRECTION_ROIS
        
        if roi_idx < 0 or roi_idx >= len(DIRECTION_ROIS):
            QMessageBox.warning(self, "Invalid Selection", "Please select a ROI to delete.")
            return
        
        reply = QMessageBox.question(
            self, "Confirm Delete",
            f"Are you sure you want to delete Direction ROI {roi_idx + 1}?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            del DIRECTION_ROIS[roi_idx]
            print(f"üóëÔ∏è Direction ROI {roi_idx + 1} deleted")
            self.status_label.setText(f"Status: ROI {roi_idx + 1} deleted. Total: {len(DIRECTION_ROIS)}")
            dialog.close()
    
    def update_lists(self):
        self.lane_list.clear()
        for idx, lane in enumerate(LANE_CONFIGS, start=1):
            allowed = lane.get('allowed_labels', ['all'])
            self.lane_list.addItem(f"Lane {idx}: {len(lane['poly'])} points - {', '.join(allowed)}")
        
        # Update direction ROI list
        self.update_direction_roi_list()
            
    def start_detection(self):
        global _detection_running
        if not _detection_running:
            if self.yolo_model is None:
                self.status_label.setText("Status: Model not loaded at startup")
                QMessageBox.warning(self, "No Model", "Please select a model first!")
                return
            
            # Check if reference vector is set (critical for direction detection accuracy)
            if self.ref_vector_p1 is None or self.ref_vector_p2 is None:
                if DIRECTION_ROIS:  # Only warn if direction ROIs exist
                    reply = QMessageBox.question(
                        self,
                        "‚ö†Ô∏è Reference Vector Not Set",
                        "Reference Vector ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p ƒë·ªÉ x√°c ƒë·ªãnh h∆∞·ªõng th·∫≥ng.\n\n"
                        "ƒêi·ªÅu n√†y C√ì TH·ªÇ ·∫¢NH H∆Ø·ªûNG ƒê·ªò CH√çNH X√ÅC khi:\n"
                        "- Ph√°t hi·ªán xe r·∫Ω tr√°i/ph·∫£i\n"
                        "- X√°c ƒë·ªãnh vi ph·∫°m ƒë√®n t√≠n hi·ªáu theo h∆∞·ªõng\n\n"
                        "‚ö†Ô∏è Khuy·∫øn ngh·ªã: Set Reference Vector tr∆∞·ªõc khi start detection\n"
                        "(Click 'Set Reference Vector' v√† ch·ªçn 2 ƒëi·ªÉm theo h∆∞·ªõng th·∫≥ng)\n\n"
                        "B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c KH√îNG C√ì Reference Vector?",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.No
                    )
                    if reply == QMessageBox.No:
                        self.status_label.setText("Status: Please set Reference Vector first")
                        return
            
            # Pass pre-loaded model to thread
            if not self.thread.model_loaded:
                self.thread.set_model(self.yolo_model)
                self.thread.model_config = self.current_model_config
            
            self.thread.detection_enabled = True
            _detection_running = True
            self.btn_start.setText("Stop Detection")
            self.action_start_detection.setText("Stop Detection")
            self.status_label.setText("Status: Detection running...")
            print("üöÄ Detection started")
        else:
            self.thread.detection_enabled = False
            _detection_running = False
            self.btn_start.setText("Start Detection")
            self.action_start_detection.setText("Start Detection")
            self.status_label.setText("Status: Detection stopped")
            print("‚èπÔ∏è Detection stopped")
            VIOLATOR_TRACK_IDS.clear()
            RED_LIGHT_VIOLATORS.clear()
            LANE_VIOLATORS.clear()
            PASSED_VEHICLES.clear()
            MOTORBIKE_COUNT.clear()
            CAR_COUNT.clear()
    
    def toggle_bbox_display(self):
        global _show_all_boxes
        # Get state from whichever control was triggered
        sender = self.sender()
        if isinstance(sender, QAction):
            # Triggered from menu - update button
            _show_all_boxes = sender.isChecked()
            self.btn_toggle_bb.setChecked(_show_all_boxes)
        else:
            # Triggered from button - update menu
            _show_all_boxes = self.btn_toggle_bb.isChecked()
            self.action_toggle_boxes.setChecked(_show_all_boxes)
        
        if _show_all_boxes:
            self.btn_toggle_bb.setText("Show All Boxes: ON")
            self.statusBar().showMessage("Status: Showing all vehicles")
            print("üì¶ Showing ALL vehicle bounding boxes")
        else:
            self.btn_toggle_bb.setText("Show Only Violators: ON")
            self.statusBar().showMessage("Status: Showing only violators")
            print("üö® Showing ONLY violator bounding boxes")
    
    def select_video(self):
        global _detection_running, VIOLATOR_TRACK_IDS, RED_LIGHT_VIOLATORS, LANE_VIOLATORS, PASSED_VEHICLES, MOTORBIKE_COUNT, CAR_COUNT
        global ALLOWED_VEHICLE_IDS, VEHICLE_CLASSES, LANE_CONFIGS, TL_ROIS, _show_all_boxes
        
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Video File",
            "",
            "Video Files (*.mp4 *.avi *.mov *.mkv);;All Files (*.*)"
        )
        
        if file_path:
            # Stop current thread
            self.thread.stop()
            
            # Start new thread with selected video
            self.video_path = file_path
            self.thread = VideoThread(self.video_path)
            self.thread.change_pixmap_signal.connect(self.update_image)
            self.thread.error_signal.connect(self.show_error)
            
            # Pass globals reference to thread
            # Use lambda for _show_all_boxes to get real-time value
            self.thread.set_globals_reference({
                'ALLOWED_VEHICLE_IDS': ALLOWED_VEHICLE_IDS,
                'VEHICLE_CLASSES': VEHICLE_CLASSES,
                'LANE_CONFIGS': LANE_CONFIGS,
                'TL_ROIS': TL_ROIS,
                'DIRECTION_ROIS': DIRECTION_ROIS,
                'get_show_all_boxes': lambda: globals()['_show_all_boxes'],
                'is_on_stop_line': is_on_stop_line,
                'check_tl_violation': check_tl_violation,
                'point_in_polygon': point_in_polygon,
                'VIOLATOR_TRACK_IDS': VIOLATOR_TRACK_IDS,
                'RED_LIGHT_VIOLATORS': RED_LIGHT_VIOLATORS,
                'LANE_VIOLATORS': LANE_VIOLATORS,
                'PASSED_VEHICLES': PASSED_VEHICLES,
                'MOTORBIKE_COUNT': MOTORBIKE_COUNT,
                'CAR_COUNT': CAR_COUNT
            })
            
            self.thread.start()
            
            # Store cap for TL detection
            self.cap = cv2.VideoCapture(self.video_path)
            
            self.status_label.setText(f"Status: Loaded {file_path.split('/')[-1]}")
            print(f"üìπ Loaded video: {file_path}")
            
            # Reset detection state
            _detection_running = False
            VIOLATOR_TRACK_IDS.clear()
            RED_LIGHT_VIOLATORS.clear()
            LANE_VIOLATORS.clear()
            PASSED_VEHICLES.clear()
            self.btn_start.setText("Start Detection")
            
            # Try to auto-load configuration for this video
            if self.config_manager.config_exists(file_path):
                print(f"üîç Found existing configuration for this video")
                if self.auto_load_configuration():
                    self.config_status_label.setText(f"‚úÖ Config: Auto-loaded from file")
                    self.config_status_label.setStyleSheet("QLabel { color: green; font-weight: bold; }")
                    self.status_label.setText(f"Status: Loaded {file_path.split('/')[-1]} [Config auto-loaded]")
                    return
            
            # No config found - reset ROIs for new video
            TL_ROIS.clear()
            LANE_CONFIGS.clear()
            DIRECTION_ROIS.clear()
            self.lane_list.clear()
            self.direction_roi_list.clear()
            self.ref_vector_p1 = None
            self.ref_vector_p2 = None
            self.ref_vector_label.setText("Ref Vector: Not set")
            self.tl_tracking_active = False
            self.config_status_label.setText("Config: No saved config found")
            self.config_status_label.setStyleSheet("QLabel { color: orange; font-style: italic; }")
            print("‚ôªÔ∏è All ROIs reset. Draw new configuration or load from file.")
    
    def load_model(self, model_type, weight_name):
        """Load model dynamically based on selection"""
        if not YOLO_AVAILABLE:
            print("‚ö†Ô∏è YOLO not available")
            return False
        
        try:
            print(f"üîÑ Loading {model_type} model: {weight_name}...")
            weight_path = get_weight_path(model_type, weight_name)
            self.yolo_model = YOLO(weight_path)
            self.current_model_type = model_type
            self.current_model_config = get_model_config(model_type)
            
            # Update thread model if thread exists and was already initialized
            if hasattr(self, 'thread') and hasattr(self.thread, 'model_loaded'):
                if self.thread.model_loaded:
                    self.thread.set_model(self.yolo_model)
                    self.thread.model_config = self.current_model_config
            
            # Update spinboxes with model's default values
            if hasattr(self, 'imgsz_spinbox'):
                self.imgsz_spinbox.setValue(self.current_model_config['default_imgsz'])
            if hasattr(self, 'conf_spinbox'):
                self.conf_spinbox.setValue(self.current_model_config['default_conf'])
            
            print(f"‚úÖ Model loaded: {weight_path}")
            if hasattr(self, 'status_label'):
                self.status_label.setText(f"Status: Loaded {model_type} - {weight_name}")
            return True
        except Exception as e:
            import traceback
            print(f"‚ùå Failed to load model: {e}")
            print(traceback.format_exc())
            if hasattr(self, 'status_label'):
                QMessageBox.warning(self, "Model Load Error", f"Could not load model:\n{e}")
            return False
    
    def update_weight_combo(self):
        """Update weight dropdown based on selected model type"""
        self.weight_combo.clear()
        
        if not self.available_models:
            return
        
        # Get current model type from combo
        current_idx = self.model_type_combo.currentIndex()
        if current_idx < 0:
            return
        
        model_type = list(self.available_models.keys())[current_idx]
        weights = self.available_models[model_type]["weights"]
        
        for weight in weights:
            self.weight_combo.addItem(weight)
    
    def update_model_info_label(self):
        """Update model info label with current config"""
        if self.current_model_config:
            # Get values from spinboxes if they exist
            imgsz = self.imgsz_spinbox.value() if hasattr(self, 'imgsz_spinbox') else self.current_model_config['default_imgsz']
            conf = self.conf_spinbox.value() if hasattr(self, 'conf_spinbox') else self.current_model_config['default_conf']
            info = f"Using: ImgSize={imgsz} | Conf={conf}"
            self.model_info_label.setText(info)
        else:
            self.model_info_label.setText("No model loaded")
    
    def on_model_type_changed(self):
        """Handle model type selection change"""
        self.update_weight_combo()
        
        # Auto-load first weight of new model type
        if self.weight_combo.count() > 0:
            self.on_weight_changed()
    
    def on_weight_changed(self):
        """Handle weight selection change"""
        if self.weight_combo.currentIndex() < 0:
            return
        
        current_idx = self.model_type_combo.currentIndex()
        if current_idx < 0:
            return
        
        model_type = list(self.available_models.keys())[current_idx]
        weight_name = self.weight_combo.currentText()
        
        if weight_name:
            success = self.load_model(model_type, weight_name)
            if success:
                # Update spinboxes with model default values
                if self.current_model_config:
                    self.imgsz_spinbox.setValue(self.current_model_config['default_imgsz'])
                    self.conf_spinbox.setValue(self.current_model_config['default_conf'])
                self.update_model_info_label()
    
    def on_imgsz_changed(self):
        """Handle image size change"""
        new_imgsz = self.imgsz_spinbox.value()
        print(f"üìê ImgSize changed to: {new_imgsz}")
        
        # Update current config
        if self.current_model_config:
            self.current_model_config['default_imgsz'] = new_imgsz
        
        # Update thread config if running
        if hasattr(self, 'thread') and self.thread.model_config:
            self.thread.model_config['default_imgsz'] = new_imgsz
            print(f"‚úÖ Thread ImgSize updated to: {new_imgsz}")
        
        self.update_model_info_label()
    
    def on_conf_changed(self):
        """Handle confidence threshold change"""
        new_conf = round(self.conf_spinbox.value(), 2)  # Round to 2 decimals
        print(f"üéØ Confidence changed to: {new_conf}")
        
        # Update current config
        if self.current_model_config:
            self.current_model_config['default_conf'] = new_conf
        
        # Update thread config if running
        if hasattr(self, 'thread') and self.thread.model_config:
            self.thread.model_config['default_conf'] = new_conf
            print(f"‚úÖ Thread Confidence updated to: {new_conf}")
        
        self.update_model_info_label()
    
    def show_error(self, error_msg):
        self.status_label.setText(f"Status: Error - {error_msg}")
        print(f"‚ùå Error: {error_msg}")
    
    def closeEvent(self, event):
        self.thread.stop()
        event.accept()

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
